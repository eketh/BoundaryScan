*register(Name, Pid)

creates a global process, and associates the atom Name with the process
identifier Pid. Thereader, messages sent by evaluating Name!Msg are sent
to the process Pid.

*Explicit exceptions can be generated by calling the exit primitive. Here
is an example:
sqrt(X) when X < 0 ->
exit({sqrt,X});
sqrt(X) ->
...
which generates the exception {sqrt,X} if called with a negative argument
X.

*The important thing to note about tail-recursive functions is that they
can run in loops without consuming stack space. Such function are oden
called “iterative functions.”

*To write this in a tail-recursive manner requires the use of an additional
function:
factorial(N) -> factorial_1(N, 1).
factorial_1(0, X) -> X;
factorial_1(N, X) -> factorial_1(N-1, N*X).


*Let us suppose that the server is in a state State and that it receives a
message Query from some client. The server should respond to this query
by returning a message Reply to the client and changing state to State1.
These values are completely determined by the server function F and
are computed by the Erlang expression:
{State1, Reply} = F(Query, State)
which is evaluated within the server.

The reader
should note the following:
• There is a total separation of functionality into two dicerent modules.
All the code that has to do with spawning processes, sending and
receiving messages etc is contained in server1.erl. All the code
that has to do with the implementation of the VSHLR is contained
in vshlr1.erl.
• The code in vshlr1.erl makes no use of any of the Erlang concurrency
primitives. The programmer who writes this module needs to
know nothing about concurrency or fault-handling.
The second point is very important. This is an example of factoring
out concurrency—since writing concurrent programs is generally perceived
as being diecult and since most programmers are more experienced in
writing sequential code then being able to factor out the concurrency is a
distinct advantage.